



export class PointC2<FT> {
    base:

       
}

// class PointC2<R_ extends any>{



//     typedef  R_.FT                   FT;
//     // https://doc.cgal.org/latest/Manual/devman_code_format.html#secprogramming_conventions
//     typedef typename R_:: Vector_2             Vector_2_;
//     typedef typename R_:: Point_2              Point_2;

//     // We do not use reference counting here as it is done at the Vector_2 level.
//     Vector_2_ base;

//                          R;


// PointC2(const FT & x, const FT & y)
//     : base(x, y) { }

// PointC2(const FT & hx, const FT & hy, const FT & hw)
//     : base(hx, hy, hw) { }


// const FT& x() const
//     {
//         return base.x();
//   }

// const FT& y() const
//     {
//         return base.y();
//   }

// const FT& hx() const
//     {
//         return base.hx();
//   }
// const FT& hy() const
//     {
//         return base.hy();
//   }
// const FT& hw() const
//     {
//         return base.hw();
//   }

// Cartesian_const_iterator cartesian_begin() const
//     {
//         return base.cartesian_begin();
//   }

// Cartesian_const_iterator cartesian_end() const
//     {
//         return base.cartesian_end();
//   }

// typename R_:: Boolean   operator == (const PointC2 & p) const
//     {
//         return base == p.base;
//   }
// typename R_:: Boolean   operator != (const PointC2 & p) const
//     {
//         return !(* this == p);
//   }

// };
